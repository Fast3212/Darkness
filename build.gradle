buildscript {
    repositories {
        jcenter()
        
        maven { 
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
       }
    }
    
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
    }
}

apply plugin: 'net.minecraftforge.gradle.forge'


group = "nuke.darkness" 
archivesBaseName = "darkness"
version = "0.0.1"

sourceCompatibility = targetCompatibility = "1.8"
compileJava {
    sourceCompatibility = targetCompatibility = "1.8"
}

minecraft {
    version = "1.11.2-13.20.0.2260"
    runDir = "run"
    mappings = "snapshot_20170405"
    
    // makeObfSourceJar = false
}

repositories {
    maven {
		// where to find the JEI files (runtime or api)
        name = 'DVS1 Maven FS'
        url = 'http://dvs1.progwml6.com/files/maven'
    }
}

dependencies {
    deobfCompile "mezz.jei:jei_1.11.2:4.3.1.257"
    //deobfCompile "com.github.Azanor:Baubles:${version_baubles}"
    compile files('libs/')
}

processResources {
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
                
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

//Pulls the build version from a Java file.
String getVersionFromJava(File file) {

    String release = "0";
    String update = "0";
    String patch = "0";

    String build = System.getenv("BUILD_NUMBER") ? System.getenv("BUILD_NUMBER") : "0";
    def outfile = "";
    def ln = System.getProperty("line.separator")

    String prefix = "public static final String VERSION_NUMBER = \"";
    file.eachLine {
        String s ->

            String v = s.trim();

        if (v.startsWith(prefix)) {

            v = v.substring(prefix.length(), v.length() - 2);
            String[] pts = v.split("\\.");

            release = pts[0];
            update = pts[1];
            patch = pts[2];
            s = s.replaceAll(".0\";", ".${build}\";");
        }

        outfile += (s + ln);
    }

    file.write(outfile);

    return "${version_minecraft}-$release.$update.$patch.$build";
}

//Creates the source jar.
task sourcesJar(type: Jar, dependsOn: classes) {

    from sourceSets.main.allSource
    classifier = 'sources'
}

//Creates the JavaDoc jar.
task javadocJar(type: Jar, dependsOn: javadoc) {

    from javadoc.destinationDir
    classifier = 'javadoc'
}

//Creates the deobfuscated jar.
task deobfJar(type: Jar) {

    from sourceSets.main.output
    classifier = "deobf"
}

//Adds the deobf, source and javadoc jars to the build artifacts.
artifacts {

    archives deobfJar
    archives sourcesJar
    archives javadocJar
}


// generates BlockModel JSON & ItemModel JSON
ext.args = [:]

ext.requireArgument = {String property, String displayValue ->
    def value = args[property]
    if (value == null) {
        throw new InvalidUserDataException("$property must be set with \'$property=$displayValue\'")
    }
    return value
}

tasks.addRule("Pattern: <property>=<value>: Passes arguments to the scripts") { String taskName ->
    def match = taskName =~ /(.*?)=(.*?$)/
    if (match) {
        def property = match[0][1]
        def value = match[0][2]
        ext.args[property] = value;
        task(taskName) << {
            println "Passes value \'$value\' to args[\'$property\']"
        }
    }
}

import org.apache.tools.ant.filters.FixCrLfFilter

class CopyJsonTemplate extends DefaultTask {
    @Input
    def template

    @Input
    def arguments

    @Input
    def jsonRename

    @TaskAction
    def build() {
        def args = arguments()
        project.copy {
            from("templates/${template}") {
                expand(args)
                filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            }
            into 'src/main/resources'
            rename { String filename ->
                def match = filename =~ /(.*)\.json/
                if (match) {
                    def prevFilename = match[0][1]
                    def newFilename = jsonRename.call(prevFilename)
                    return "${newFilename}.json"
                }
                else {
                    return filename
                }
            }
        }
    }
}


task generateBlockModel(type: CopyJsonTemplate) {
    template 'block'
    arguments {
        def blockName = requireArgument('blockName', 'block_name')
        return ['modid':archivesBaseName, 'block_name':blockName]
    }
    jsonRename {
        return args['blockName']
    }
}

task generateItemModel(type: CopyJsonTemplate) {
    template 'item'
    arguments {
        def itemName = requireArgument('itemName', 'item_name')
        return ['modid':archivesBaseName, 'item_name':itemName]
    }
    jsonRename {
        return args['itemName']
    }
}
